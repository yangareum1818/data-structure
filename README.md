# data-structure

* 자료구조를 왜 공부하는지 ?
  * 알고리즘과 연관되어 있다고 느끼기에 코딩테스트를 좀 더 이해하면서 풀기위해 공부한다.

## 시간복잡도

![시간복잡도](/images/Time_complexity.png)

## 연결리스트

![연결리스트](/images/linkedlist.png)

## 스택과 큐

![스택과 큐](/images/stack_queue.png)

## 트리와 이진트리

## 이진탐색트리

### 1. 삽입에 대한 정리. `insert()`

1. 어떤 값을 넣으려고할 때, 일단 어디에 넣을지 모르겠다.
2. 그래서 왼쪽, 오른쪽에게 위임한다. ( 맡긴다, 처리하라고 한다. )
3. 근데 만약, 왼쪽 또는 오른쪽이 없다면 그 자리에 삽입한다.

![이진탐색트리 삽입](/images/binarysearchtree_insert.png)
>5, 9, 4, 14, 19, 23, 7, 11, 2, 16 <br/>
5입장에서 11을 넣으려고 할 때, 9와 14에게 위임한 뒤, 11을 추가할 수 있다.<br/>
14에게 위임할 때, 왼쪽을 찾으려고 했더니 왼쪽이 없는 상황이다.<br/>
11을 넣고자 하는 상황에 왼쪽이 비어있다는 것을 인지한다.<br/><br/>
상위 값보다 넣으려는 값이 큰지, 작은지를 인지(조건문)하고 값을 넣으려고 할 때, __깔끔하고 명확하게 넣어줘야하기 때문에__ 추가적으로 그 자리에 값이 있는지 없는지를 판단하는 조건을 추가해 있다면 또는 없다면 어떻게 처리 할 것인지를 또 한번 걸러준다.<br/>
(이것이 __재귀함수를 사용하는 것__ 이다.)

```javascript
#insert(node, value) {
  if (node.value > value) {
    // 상위 값보다 넣으려고 하는 값이 작으면
    if (node.left) {
      // 왼쪽에 값이 있으면, 왼쪽에 있는 값에게 처리를 넘김
      this.#insert(node.left, value);
    } else {
      // 만약 왼쪽이 비어있다면? 왼쪽에 추가
      node.left = new Node(value);
    }
  } else {
    // 상위 값보다 넣으려고 하는 값이 크면
    if (node.right) {
      // 오른쪽에 값이 있으면, 오른쪽에 있는 값에게 처리를 넘김
      this.#insert(node.right, value);
    } else {
      // 만약 오른쪽이 비어있다면? 오른쪽에 추가
      node.right = new Node(value);
    }
  }
}
```

<br/>

### 2. 검색(조회)에 대한 정리 `search()`

* 해당 값을 검사하고 찾아 처리해줘야하기 때문에, 모든 값을 `return` 해줘야한다.
* 수정은 검색(조회)를 활용한다.
* `#insert()`재귀함수와 동일한 조건의 틀을 가진다.
  * 찾는 값과 해당 node가 같은지와 결과를 `return`을 해줘야하는 부분만  다르다.

1. 11을 찾는다고 가정하고 코드의 흐름을 따라간다.
2. 또, 없는 값을 생각하고 어떻게 코드가 흐르는지도 파악한다. ( 어떻게 해서 `null`을 `return` 하는지 )
